{
  // SETTINGS FOR EASY_CLANG_COMPLETE.

  // Every path variable in settings can contain wildcards (without the ""):
  //  - "$project_base_path"  <-- replaced by the full path to the project to
  //                              which the currently opened view belongs.
  //  - "$project_name"       <-- replaced by the name of the current project.
  //  - "$clang_version"      <-- replaced by the numeric version of used clang.
  //  - "~"                   <-- replaced by the path to user home directory.
  //  - "*"                   <-- when put at the end of folder path expands to
  //                              all folders in that folder. Not recursive.
  //
  //  In addition to these, you can use your environment variables:
  //  - OSX and Linux:  $variable_name or ${variable_name}
  //  - Windows:        $variable_name or ${variable_name} or %variable_name%

  // Specify common flags that will be passed to clang for EVERY build.
  "common_flags" : [
    // some example includes
    "-I/usr/include",
    "-I$project_base_path/src",
    // this is needed to include the correct headers for clang
    "-I/usr/lib/clang/$clang_version/include",
  ],

  // Language-specific flags. Prepend common_flags for files of given language.
  // When adapting to your needs, make sure to keep all language keys.
  "lang_flags": {
    "C": ["-std=c17"],
    "CPP": ["-std=c++17"],
    "OBJECTIVE_C": ["-std=c11"],
    "OBJECTIVE_CPP": ["-std=c++11"],
  },

  // Define how we search needed flags. Prioritized from top to bottom.
  // Possible entries for "file":
  //  - "CMakeLists.txt"
  //  - "compile_commands.json"
  //  - ".clang_complete"
  //
  // Every entry has an option:
  //  - "search_in": <path>  <-- a path to the folder containing the file.
  //
  // "cmake" entry has additional options:
  //  - "flags": [<flags>]        <-- Additional flags to pass to cmake.
  //  - "prefix_paths": [<paths>] <-- array of folders that should be
  //                                  appended to CMAKE_PREFIX_PATHS before
  //                                  cmake is run.
  "flags_sources": [
    {"file": "CMakeLists.txt"},
    {"file": "compile_commands.json"},
    {"file": "CppProperties.json"},
    {"file": "c_cpp_properties.json"},
    {"file": ".clang_complete"},
  ],

  // Show compile errors on file save or not.
  "show_errors": true,

  // Show gutter icon for highlighted errors on the side bar.
  // Possible styles: "color", "mono", "dot", "none"
  "gutter_style": "color",

  // Maximum width and height for popups eg. declaration info.
  "popup_maximum_width": 1800,
  "popup_maximum_height": 800,

  // Triggers for auto-completion
  "triggers" : [ ".", "->", "::", " ", "	", "(", "[" ],

  // A dictionary that defines a mapping from language to an array of valid
  // syntaxes for it. The values here are good defaults, but feel free to
  // customize the list to your liking. When modifying this setting make sure
  // that all 4 languages have values.
  "valid_lang_syntaxes": {
    "C":              ["C", "C Improved", "C99"],
    "CPP":            ["C++", "C++11"],
    "OBJECTIVE_C":    ["Objective-C"],
    "OBJECTIVE_CPP":  ["Objective-C++"]
  },

  // Do not run the plugin for any files that match these paths. Use
  // glob/fnmatch shell-style filename expansion. In addition, you can still use
  // '~' to mark the home directory.
  "ignore_list": [
    "~/some_folder/*",
    "/some/absolute/file.ext",
    "$project_base_path/some/project/path/*",
  ],

  // Use libclang.
  // If set to false will use clang_binary and parse the output of
  // `clang_binary -Xclang -code-complete-at...` instead.
  "use_libclang" : true,

  // Use default includes that we get from running the command:
  // `clang_binary -c /tmp/test.cc -v`
  "use_default_includes": true,

  // make plugin verbose
  "verbose" : false,

  // add folder with current file with `-I` flag
  "include_file_folder" : true,

  // add parent folder of the current file's one with `-I` flag
  "include_file_parent_folder" : true,

  // pick the clang binary used by the plugin. This is used to determine the
  // version of the plugin and pick correct libclang bindings.
  "clang_binary" : "clang++",

  // pick the binary used for cmake. Please make sure the binary you provide is
  // accessible from the command line on your system.
  "cmake_binary" : "cmake",

  // ignore triggers and try to complete after each character
  // WARNING: can be very slow
  "autocomplete_all" : false,

  // hide the completions generated by other plugins
  "hide_default_completions": false,

  // Plugin uses smart caching to not load the data more times than needed.
  // Remove cache data older than specified time. Minimum value is 30 seconds.
  // Format: <hours>:<minutes>:<seconds>: "HH:MM:SS".
  "max_cache_age": "00:30:00",

  // Show additional information on hover over function call/variable etc.
  // This replaces default sublime on hover behaviour
  "show_type_info": true,

  // Show body of struct/class/typedef declaration.
  "show_type_body" : true,

  // On some esoteric systems we cannot find libclang properly.
  // If you know where your libclang is - set the full path here.
  "libclang_path": "<some_path_here>",

  // Pick the progress style. There are currently these styles available:
  // - "ColorSublime" : 'â£¾â£½â£»â¢¿â¡¿â£Ÿâ£¯â£·'
  // - "Moon"         : 'ðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜'
  // - "None"
  "progress_style": "ColorSublime",

  // Controls if libclang will cache the results.
  // This works faster, but in rare cases can generate wrong completions.
  "use_libclang_caching": true,

  // Templates to find source files for headers in case we use a
  // compilation database: Such a DB does not contain the required
  // compile flags for header files. In order to find a best matching
  // source file instead, you can use templates. Such templates describe how
  // to find (relative to the header file) a source file which we can
  // use to get compile flags for.
  // In the simplest case, one can just use the (relative) path to where
  // the source files are relative to your header file. For example, if
  // your headers are in a subdirectory "inc" and your sources in a
  // subdirectory "src" next to the first one, then you can use
  // "../src/" as lookup.
  // If needed, you can also use finer granular lookup templates by using
  // UNIX style globbing patterns and placeholders. Placeholders are of the
  // form '{placeholdername}'. The following placeholders can be used:
  // - basename:  The base file name without the directory part.
  // - stamp:     Like "basename", but with the file name extension removed.
  // - ext:       The file name extension of the header file.
  "header_to_source_mapping": [
    // Look for related files in the header's directory:
    "./",

    // And in the "src" directory:
    "../src/",

    // And in the "source" directory:
    "../source/",

    // Example: Use flags but only from the source file
    // belonging to the header in question:
    // "{stamp}.cpp",

    // Example: Use flags from a file with an
    // "exotic" file name suffix:
    // "{stamp}.mycustomext
  ],

  // Controls if we try to retrieve built-in flags from the target compiler.
  // This option is used when we use a `compile_commands.json` file
  // either directly or indirectly e.g. via CMake.
  // If set to true, we try to ask the compiler for the defines and
  // include paths it sets implicitly and pass them to the
  // clang compiler which is used to generate the code completion.
  // Usually, this option should improve the quality of the
  // completions, however, in some corner cases it might cause
  // completions to fails entirely.
  "use_target_compiler_built_in_flags": false,

  // Target compilers.
  // The below options allow to set the actual target compilers (i.e.
  // the one you use in your build chain). If they are set, we will
  // ask the compilers for their built in flags (defines and include
  // paths) and pass them to the clang compiler to generate code
  // completions. This is especially useful when working with
  // non-host tool chains, where the compilers might set additional
  // target specific defines which are now seen by the (host) clang
  // compiler.
  // Note: These settings are only used if the target compiler
  // cannot be retrieved otherwise, e.g. from a `compile_commands.json`
  // file.
  // Note: The set compilers will also be passed to CMake if you use
  // it as source.
  "target_c_compiler": null,
  "target_cpp_compiler": null,
  "target_objective_c_compiler": null,
  "target_objective_cpp_compiler": null,
}
